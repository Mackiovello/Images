<!--
Copyright 2015 Smörgåsbord Development. All rights reserved.

@element juicy-filedrop
@demo https://Juicy.github.io/juicy-filedrop/
version: 1.0.3

Add web socket support
-->
<link rel="import" href="/sys/polymer/polymer.html">

<dom-module id="juicy-filedrop">
    <template>
        <style>
            :host {
                display: -webkit-box;
                display: -moz-box;
                display: -ms-flexbox;
                display: -webkit-flex;
                display: flex;
            }

            input[type=file] {
                display: none;
            }
        </style>
        <input type="file" id="txtUploadFile">
        <content id="content"></content>
    </template>
    <script>
        'use strict';
        Polymer({
            is: 'juicy-filedrop',
            properties: {
                allowedmimetypes: {
                    notify: true
                },
                customheader: {
                    type: String,
                    value: 'x-file',
                    notify: true
                },
                maxfilesize: {
                    notify: true
                },
                url: {
                    type: String,
                    value: '',
                    notify: true
                },
                value: {
                    notify: true
                },
                filetype: {
                    notify: true
                },
                chunkLength: {
                    type: Number,
                    value: 8192
                },
                sessionid: {
                    notify: true
                },
                progress: {
                    type: Number,
                    notify: true
                }
            },
            ready: function () {
                this.setupDrop();
                this.setupSelect();
                if (!this.maxfilesize) {
                    this.maxfilesize = 524288; //512kb
                }
                //512kb
                if (!this.allowedmimetypes) {
                    this.allowedmimetypes = [
                        'image/gif',
                        'image/jpeg',
                        'image/png',
                        'image/svg+xml'
                    ];
                } else if (typeof this.allowedmimetypes == 'string') {
                    this.allowedmimetypes = this.allowedmimetypes.split(',');
                }
            },
            checkFile: function (file) {
                var m;
                if (this.allowedmimetypes.indexOf(file.type) < 0) {
                    if (file.type) {
                        m = 'File type [' + file.type + '] is not allowed.';
                    } else {
                        m = file.name + ' has invalid mime type.';
                    }
                    this.fire('fileSelectError', {
                        file: file,
                        message: m
                    });
                    return false;
                }
                if (file.size > this.maxfilesize) {
                    m = [
                        'File ',
                        file.name,
                        ' is too big. Maximum file size is: ',
                        this.maxfilesize / 1024,
                        'kb.'
                    ].join('');
                    this.fire('fileSelectError', {
                        file: file,
                        message: m
                    });
                    return false;
                }
                return true;
            },
            openFile: function () {
                var element = this.$.txtUploadFile;
                element.click();
            },
            fileToJson: function (file) {
                return JSON.stringify({
                    type: file.type,
                    name: encodeURIComponent(file.name)
                });
            },
            processTask: function (task) {
                var that = this;
                this.set("tasks.error", null);
                var self = this;
                this.progress = 0;
                this.filetype = "";
                this.value = "";
                this.executeTask(task, function (task) {
                    // Success
                    that.fire("statechange", task);
                    that.progress = 0;
                    that.value = task.fileUrl;
                    that.filetype = task.file.type;
                }, function (task) {
                    // Error
                    self.notifyPath("tasks.error", task.error);
                    that.progress = 0;
                    console.log(task.error)
                    that.fire("statechange", task);
                }, function (task) {
                    // Progress
                    if (task) {
                        self.notifyPath("tasks.progress", task.progress);
                        that.fire("statechange", task);
                        that.progress = task.progress;
                    }
                });
            },
            executeTask: function (task, successCallback, errorCallback, progressCallback) {
                task.progress = 0;

                try {
                    this.uploadTask(task, successCallback, errorCallback, progressCallback);
                } catch (ex) {
                    task.error = ex;
                    console.error(task.error);

                    if (typeof (errorCallback) == "function") {
                        errorCallback(task);
                    }
                }
            },
            uploadTask: function (task, successCallback, errorCallback, progressCallback) {
                var file = task.file;
                var chunkLength = this.chunkLength;
                var url = this.getUploadUrl(file);
                var socket = new WebSocket(url);

                task.socket = socket;

                socket.onopen = function () {
                    var reader = new FileReader();
                    var currentBytePosition = 0;

                    reader.onloadend = function (evt) {
                        if (evt.target.readyState == FileReader.DONE) {
                            if (socket == null || socket.readyState != 1) {
                                // Not OPEN
                                return;
                            }

                            socket.send(evt.currentTarget.result);
                            currentBytePosition = currentBytePosition + evt.loaded;

                            if (currentBytePosition >= file.size) {
                                return;
                            }

                            // Load next chunk
                            var endByte = currentBytePosition + chunkLength;

                            if (endByte > file.size) {
                                endByte = file.size;
                            }

                            var blob = file.slice(currentBytePosition, currentBytePosition + chunkLength);
                            reader.readAsArrayBuffer(blob);
                        }
                    };

                    var blob = file.slice(currentBytePosition, currentBytePosition + chunkLength);
                    reader.readAsArrayBuffer(blob);
                };

                socket.onclose = function (evt) {
                    socket = null;

                    if (evt.code == 1000 || evt.code == 1005) { // CLOSE_NORMAL
                        if (typeof (successCallback) == "function") {
                            successCallback(task);
                        }
                    } else {
                        if (evt.reason) {
                            task.error = evt.reason + " (" + evt.code + ")";
                        }
                        else {
                            task.error = "Socket Error code: " + evt.code;
                        }

                        if (typeof (errorCallback) == "function") {
                            errorCallback(task);
                        }
                    }
                };

                socket.onmessage = function (evt) {
                    var json = JSON.parse(evt.data);
                    task.progress = json.progress;
                    task.fileUrl = json.fileUrl;

                    if (task.progress >= 100) {
                        socket.close(1000);
                    }

                    if (typeof (progressCallback) == "function") {
                        progressCallback(task);
                    }
                };

                socket.onerror = function (evt) {
                    console.error("Socket error: ", JSON.stringify(evt));
                };
            },
            getUploadUrl: function (file) {
                var url = this.url + "?filename=" + file.name + "&filesize=" + file.size + "&sessionid=" + this.sessionid;

                url = new URL(url, window.location);
                url.protocol = "ws:";
                url = url.toString();

                return url;
            },
            readData: function (file) {
                var reader = new FileReader();
                var that = this;

                var task = {
                    file: file,
                    error: null
                };

                this.fire("statechange", task);
                this.processTask(task);
            },
            setupSelect: function () {
                var onFileSelected = function (e) {
                    var files = e.target.files;
                    for (var i = 0; i < files.length; i++) {
                        var file = files[i];
                        if (!this.checkFile(file)) {
                            continue;
                        }
                        this.readData(files[i]);
                    }
                };
                this.$.txtUploadFile.addEventListener('change', onFileSelected.bind(this), false);
            },
            setupDrop: function () {
                if (typeof window.FileReader === 'undefined') { } // TODO: Browser does not support 'FileReader'
                // TODO: Browser does not support 'FileReader'
                this.onpaste = function (event) {
                    for (var i = 0, item; item = event.clipboardData.items[i]; i++) {
                        if (item.kind == 'file') {
                            var blob = item.getAsFile();
                            this.readData(blob);
                        }
                    }
                };
                this.ondragleave = function () {
                    if (this.classList.contains('hover')) {
                        this.classList.remove('hover');
                    }
                };
                this.ondragover = function (e) {
                    e.stopPropagation();
                    if (!this.classList.contains('hover')) {
                        this.classList.add('hover');
                    }
                    return false;
                };
                this.ondragend = function () {
                    if (this.classList.contains('hover')) {
                        this.classList.remove('hover');
                    }
                    return false;
                };
                this.ondrop = function (e) {
                    if (this.classList.contains('hover')) {
                        this.classList.remove('hover');
                    }
                    e.preventDefault();
                    var that = this;
                    for (var i = 0, file; file = e.dataTransfer.files[i]; i++) {
                        if (!this.checkFile(file)) {
                            continue;
                        }
                        this.readData(file);
                    }
                    return false;
                };
            },
            handleResponse: function (ev, xhr) {
                this.value = xhr.getResponseHeader('x-file-location');
                var xFile = JSON.parse(xhr.getResponseHeader(this.customheader));
                xFile.status = xhr.status;
                xFile.statusText = xhr.statusText;
                this.fire('fileUploaded', xFile);
            },
            handleError: function (ev, xhr) {
                var xFile = xhr.xFile;
                xFile.status = xhr.status;
                xFile.statusText = xhr.statusText;
                this.fire('fileUploadError', xFile);
            }
        });
    </script>
</dom-module>
